[{"name":"NoBooleanCaseOf","comment":"\n\n@docs rule\n\n","unions":[],"aliases":[],"values":[{"name":"rule","comment":" Reports when pattern matching is used for a boolean value.\n\nThe idiomatic way to check for a condition is to use an `if` expression.\nRead more about it at: <https://guide.elm-lang.org/core_language.html#if-expressions>\n\n    config =\n        [ NoBooleanCaseOf.rule\n        ]\n\nThis won't report pattern matching when a boolean is part of the evaluated value.\n\n\n## Fail\n\n    _ =\n        case bool of\n            True ->\n                expression\n\n            False ->\n                otherExpression\n\n\n## Success\n\n    _ =\n        if bool then\n            expression\n\n        else\n            otherExpression\n\n    _ =\n        case ( bool, somethingElse ) of\n            ( True, SomeThingElse ) ->\n                expression\n\n            _ ->\n                otherExpression\n\n\n# When (not) to use this rule\n\nYou should not use this rule if you do not care about how your boolean values are\nevaluated.\n\n\n## Try it out\n\nYou can try this rule out by running the following command:\n\n```bash\nelm-review --template jfmengels/elm-review-simplify/example --rules NoBooleanCaseOf\n```\n\n","type":"Review.Rule.Rule"}],"binops":[]},{"name":"Simplify","comment":"\n\n@docs rule\n\n","unions":[],"aliases":[],"values":[{"name":"rule","comment":" Reports when an operation can be simplified.\n\n    config =\n        [ Simplify.rule\n        ]\n\n\n## Try it out\n\nYou can try this rule out by running the following command:\n\n```bash\nelm-review --template jfmengels/elm-review-simplify/example --rules Simplify\n```\n\n\n## Simplifications\n\nBelow is the list of all kinds of simplifications this rule applies.\n\n\n### Booleans\n\n    x || True\n    --> True\n\n    x || False\n    --> x\n\n    x && True\n    --> x\n\n    x && False\n    --> False\n\n    not True\n    --> False\n\n    x == True\n    --> x\n\n    x /= False\n    --> x\n\n    not x == not y\n    --> x == y\n\n    anything == anything\n    --> True\n\n    anything /= anything\n    --> False\n\n    not >> not\n    --> identity\n\n\n### If expressions\n\n    if True then x else y\n    --> x\n\n    if False then x else y\n    --> y\n\n    if condition then x else x\n    --> x\n\n    if condition then True else False\n    --> condition\n\n    if condition then False else True\n    --> not condition\n\n\n### Basics functions\n\n    identity x\n    --> x\n\n    f >> identity\n    --> f\n\n    always x y\n    --> x\n\n\n### Operators\n\n    (++) a b\n    --> a ++ b\n\n\n### Numbers\n\n    negate >> negate\n    --> identity\n\n\n### Strings\n\n    \"a\" ++ \"\"\n    --> \"a\"\n\n    String.isEmpty \"\"\n    --> True\n\n    String.isEmpty \"a\"\n    --> False\n\n    String.concat []\n    --> \"\"\n\n    String.join str []\n    --> \"\"\n\n    String.join \"\" list\n    --> String.concat list\n\n    String.length \"abc\"\n    --> 3\n\n    String.repeat n \"\"\n    --> \"\"\n\n    String.repeat 0 str\n    --> \"\"\n\n    String.repeat 1 str\n    --> str\n\n    String.words \"\"\n    --> []\n\n    String.lines \"\"\n    --> []\n\n\n### Lists\n\n    a :: []\n    --> [ a ]\n\n    a :: [ b ]\n    --> [ a, b ]\n\n    [a] ++ list\n    --> a :: list\n\n    [] ++ list\n    --> list\n\n    [ a, b ] ++ [ c ]\n    --> [ a, b, c ]\n\n    [ a, b ] ++ [ c ]\n    --> [ a, b, c ]\n\n    List.concat []\n    --> []\n\n    List.concat [ [ a, b ], [ c ] ]\n    --> [ a, b, c ]\n\n    List.concat [ a, [ 1 ], [ 2 ] ]\n    --> List.concat [ a, [ 1, 2 ] ]\n\n    List.concatMap identity x\n    --> List.concat list\n\n    List.concatMap identity\n    --> List.concat\n\n    List.concatMap (\\a -> a) list\n    --> List.concat list\n\n    List.concatMap fn [ x ]\n    --> fn x\n\n    List.concatMap (always []) list\n    --> []\n\n    List.map fn [] -- same for List.filter, List.filterMap, ...\n    --> []\n\n    List.map identity list\n    --> list\n\n    List.map identity\n    --> identity\n\n    List.filter (always True) list\n    --> list\n\n    List.filter (\\a -> True) list\n    --> list\n\n    List.filter (always False) list\n    --> []\n\n    List.filter (always True)\n    --> identity\n\n    List.filter (always False)\n    --> always []\n\n    List.filterMap Just list\n    --> list\n\n    List.filterMap (\\a -> Just a) list\n    --> list\n\n    List.filterMap Just\n    --> identity\n\n    List.filterMap (always Nothing) list\n    --> []\n\n    List.filterMap (always Nothing)\n    --> (always [])\n\n    List.isEmpty []\n    --> True\n\n    List.isEmpty [ a ]\n    --> False\n\n    List.isEmpty (x :: xs)\n    --> False\n\n    List.all fn []\n    --> True\n\n    List.all (always True) list\n    --> True\n\n    List.any fn []\n    --> True\n\n    List.any (always False) list\n    --> True\n\n    List.range 6 3\n    --> []\n\n    List.length [ a ]\n    --> 1\n\n    List.repeat n []\n    --> []\n\n    List.repeat 0 str\n    --> []\n\n    List.repeat 1 str\n    --> str\n\n","type":"Review.Rule.Rule"}],"binops":[]}]