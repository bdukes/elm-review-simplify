[{"name":"NoBooleanCaseOf","comment":"\n\n@docs rule\n\n","unions":[],"aliases":[],"values":[{"name":"rule","comment":" Reports when pattern matching is used for a boolean value.\n\nThe idiomatic way to check for a condition is to use an `if` expression.\nRead more about it at: <https://guide.elm-lang.org/core_language.html#if-expressions>\n\n    config =\n        [ NoBooleanCaseOf.rule\n        ]\n\nThis won't report pattern matching when a boolean is part of the evaluated value.\n\n\n## Fail\n\n    _ =\n        case bool of\n            True ->\n                expression\n\n            False ->\n                otherExpression\n\n\n## Success\n\n    _ =\n        if bool then\n            expression\n\n        else\n            otherExpression\n\n    _ =\n        case ( bool, somethingElse ) of\n            ( True, SomeThingElse ) ->\n                expression\n\n            _ ->\n                otherExpression\n\n\n# When (not) to use this rule\n\nYou should not use this rule if you do not care about how your boolean values are\nevaluated.\n\n\n## Try it out\n\nYou can try this rule out by running the following command:\n\n```bash\nelm-review --template jfmengels/elm-review-simplification/example --rules NoBooleanCaseOf\n```\n\n","type":"Review.Rule.Rule"}],"binops":[]},{"name":"NoFullyAppliedPrefixOperator","comment":"\n\n@docs rule\n\n","unions":[],"aliases":[],"values":[{"name":"rule","comment":" Reports when an operator is used as a prefix operator and all the operands are already given.\n\n    config =\n        [ NoFullyAppliedPrefixOperator.rule\n        ]\n\n\n## Fail\n\n    _ =\n        (+) 1 2\n\n\n## Success\n\n    _ =\n        1 + 2\n\n    _ =\n        (+) 1\n\n    _ =\n        (+)\n\n\n## Try it out\n\nYou can try this rule out by running the following command:\n\n```bash\nelm-review --template jfmengels/elm-review-simplification/example --rules NoFullyAppliedPrefixOperator\n```\n\n","type":"Review.Rule.Rule"}],"binops":[]},{"name":"Simplify","comment":"\n\n@docs rule\n\n","unions":[],"aliases":[],"values":[{"name":"rule","comment":" Reports when an operation on lists could be simplified to a single literal list.\n\n    config =\n        [ Simplify.rule\n        ]\n\n\n## Simplifications\n\n\n### Booleans\n\n    x || True\n    -- True\n\n    x || False\n    -- x\n\n    x && True\n    -- x\n\n    x && False\n    -- False\n\n    not True\n    -- False\n\n    anything == anything\n    -- True\n\n    anything /= anything\n    -- False\n\n\n### Lists\n\n    a :: []\n    --> [ a ]\n\n    a :: [ b ]\n    --> [ a, b ]\n\n    [a] ++ list\n    --> a :: list\n\n    [] ++ list\n    --> list\n\n    [ a, b ] ++ [ c ]\n    --> [ a, b, c ]\n\n    [ a, b ] ++ [ c ]\n    --> [ a, b, c ]\n\n    List.concat []\n    --> []\n\n    List.concat [ [ a, b ], [ c ] ]\n    --> [ a, b, c ]\n\n    List.concat [ a, [ 1 ], [ 2 ] ]\n    --> List.concat [ a, [ 1, 2 ] ]\n\n    List.concatMap identity x\n    --> List.concat list\n\n    List.concatMap identity\n    --> List.concat\n\n    List.concatMap (\\a -> a) list\n    --> List.concat list\n\n    List.concatMap fn [ x ]\n    --> fn x\n\n    List.concatMap (always []) list\n    --> []\n\n    List.map fn [] -- same for List.filter, List.filterMap, List.concatMap\n    --> []\n\n    List.map identity list\n    --> list\n\n    List.map identity\n    --> identity\n\n    List.filter (always True) list\n    --> list\n\n    List.filter (\\a -> True) list\n    --> list\n\n    List.filter (always False) list\n    --> []\n\n    List.filter (always True)\n    --> identity\n\n    List.filter (always False)\n    --> always []\n\n    List.filterMap Just list\n    --> list\n\n    List.filterMap (\\a -> Just a) list\n    --> list\n\n    List.filterMap Just\n    --> identity\n\n    List.filterMap (always Nothing) list\n    --> []\n\n    List.filterMap (always Nothing)\n    --> (always [])\n\n    List.isEmpty []\n    --> True\n\n    List.isEmpty [ a ]\n    --> False\n\n    List.isEmpty (x :: xs)\n    --> False\n\n    List.all fn []\n    --> True\n\n    List.all (always True) list\n    --> True\n\n    List.any fn []\n    --> True\n\n    List.any (always False) list\n    --> True\n\n\n## Success\n\n    _ =\n        [ 1, 2, 3, 4, mysteryNumber, 6 ]\n\n    _ =\n        [ 1, 2, 3 ] ++ list ++ [ 4, mysteryNumber, 6 ]\n\n    _ =\n        List.concat\n            [ [ 1, 2, 3 ]\n            , list\n            , [ 4, mysteryNumber, 6 ]\n            ]\n\n\n## Try it out\n\nYou can try this rule out by running the following command:\n\n```bash\nelm-review --template jfmengels/elm-review-simplification/example --rules Simplify\n```\n\n","type":"Review.Rule.Rule"}],"binops":[]},{"name":"Simplify.Ifs","comment":"\n\n@docs rule\n\n","unions":[],"aliases":[],"values":[{"name":"rule","comment":" Reports and fixes unnecessary `if` conditions, because the branch that will be taken is always the same and can be determined at compile-time.\n\n    config =\n        [ Simplify.Ifs.rule\n        ]\n\n\n## Fail\n\n    a =\n        if True then\n            1\n\n        else\n            -- Unnecessary branch\n            2\n\n    b =\n        if False then\n            -- Unnecessary branch\n            1\n\n        else\n            2\n\n\n## Success\n\n    a =\n        if condition then\n            1\n\n        else\n            2\n\n\n## Try it out\n\nYou can try this rule out by running the following command:\n\n```bash\nelm-review --template jfmengels/elm-review-simplification/example --rules Simplify.Ifs\n```\n\n","type":"Review.Rule.Rule"}],"binops":[]}]