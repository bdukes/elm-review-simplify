[{"name":"Simplify","comment":"\n\n@docs rule\n\n","unions":[],"aliases":[],"values":[{"name":"rule","comment":" Reports when an expression can be simplified.\n\n    config =\n        [ Simplify.rule\n        ]\n\n\n## Try it out\n\nYou can try this rule out by running the following command:\n\n```bash\nelm-review --template jfmengels/elm-review-simplify/example --rules Simplify\n```\n\n\n## Simplifications\n\nBelow is the list of all kinds of simplifications this rule applies.\n\n\n### Booleans\n\n    x || True\n    --> True\n\n    x || False\n    --> x\n\n    x && True\n    --> x\n\n    x && False\n    --> False\n\n    not True\n    --> False\n\n    x == True\n    --> x\n\n    x /= False\n    --> x\n\n    not x == not y\n    --> x == y\n\n    anything == anything\n    --> True\n\n    anything /= anything\n    --> False\n\n    not >> not\n    --> identity\n\n\n### If expressions\n\n    if True then x else y\n    --> x\n\n    if False then x else y\n    --> y\n\n    if condition then x else x\n    --> x\n\n    if condition then True else False\n    --> condition\n\n    if condition then False else True\n    --> not condition\n\n\n### Case expressions\n\n    case condition of\n        True -> x\n        False -> y\n    --> if condition then x else y\n\n    case condition of\n        False -> y\n        True -> x\n    --> if not condition then x else y\n\n    case value of\n        A _ -> x\n        B -> x\n    --> x\n\n\n### Basics functions\n\n    identity x\n    --> x\n\n    f >> identity\n    --> f\n\n    always x y\n    --> x\n\n    f >> always x\n    --> always x\n\n\n### Lambdas\n\n    (\\\\() -> x) data\n    --> x\n\n    (\\\\() y -> x) data\n    --> (\\y -> x)\n\n    (\\\\_ y -> x) data\n    --> (\\y -> x)\n\n\n### Operators\n\n    (++) a b\n    --> a ++ b\n\n\n### Numbers\n\n    n + 0\n    --> n\n\n    n - 0\n    --> n\n\n    0 - n\n    --> -n\n\n    n * 1\n    --> n\n\n    n * 0\n    --> 0\n\n    n / 1\n    --> n\n\n    -(-n)\n    --> n\n\n    negate >> negate\n    --> identity\n\n\n### Strings\n\n    \"a\" ++ \"\"\n    --> \"a\"\n\n    String.isEmpty \"\"\n    --> True\n\n    String.isEmpty \"a\"\n    --> False\n\n    String.concat []\n    --> \"\"\n\n    String.join str []\n    --> \"\"\n\n    String.join \"\" list\n    --> String.concat list\n\n    String.length \"abc\"\n    --> 3\n\n    String.repeat n \"\"\n    --> \"\"\n\n    String.repeat 0 str\n    --> \"\"\n\n    String.repeat 1 str\n    --> str\n\n    String.words \"\"\n    --> []\n\n    String.lines \"\"\n    --> []\n\n\n### Maybe\n\n    Maybe.map identity x\n    --> x\n\n    Maybe.map f Nothing\n    --> Nothing\n\n    Maybe.andThen f Nothing\n    --> Nothing\n\n    Maybe.withDefault x Nothing\n    --> x\n\n    Maybe.withDefault x (Just y)\n    --> y\n\n\n### Lists\n\n    a :: []\n    --> [ a ]\n\n    a :: [ b ]\n    --> [ a, b ]\n\n    [a] ++ list\n    --> a :: list\n\n    [] ++ list\n    --> list\n\n    [ a, b ] ++ [ c ]\n    --> [ a, b, c ]\n\n    [ a, b ] ++ [ c ]\n    --> [ a, b, c ]\n\n    List.concat []\n    --> []\n\n    List.concat [ [ a, b ], [ c ] ]\n    --> [ a, b, c ]\n\n    List.concat [ a, [ 1 ], [ 2 ] ]\n    --> List.concat [ a, [ 1, 2 ] ]\n\n    List.concatMap identity x\n    --> List.concat list\n\n    List.concatMap identity\n    --> List.concat\n\n    List.concatMap (\\a -> a) list\n    --> List.concat list\n\n    List.concatMap fn [ x ]\n    --> fn x\n\n    List.concatMap (always []) list\n    --> []\n\n    List.map fn [] -- same for List.filter, List.filterMap, ...\n    --> []\n\n    List.map identity list\n    --> list\n\n    List.map identity\n    --> identity\n\n    List.filter (always True) list\n    --> list\n\n    List.filter (\\a -> True) list\n    --> list\n\n    List.filter (always False) list\n    --> []\n\n    List.filter (always True)\n    --> identity\n\n    List.filter (always False)\n    --> always []\n\n    List.filterMap Just list\n    --> list\n\n    List.filterMap (\\a -> Just a) list\n    --> list\n\n    List.filterMap Just\n    --> identity\n\n    List.filterMap (always Nothing) list\n    --> []\n\n    List.filterMap (always Nothing)\n    --> (always [])\n\n    List.isEmpty []\n    --> True\n\n    List.isEmpty [ a ]\n    --> False\n\n    List.isEmpty (x :: xs)\n    --> False\n\n    List.all fn []\n    --> True\n\n    List.all (always True) list\n    --> True\n\n    List.any fn []\n    --> True\n\n    List.any (always False) list\n    --> True\n\n    List.range 6 3\n    --> []\n\n    List.length [ a ]\n    --> 1\n\n    List.repeat n []\n    --> []\n\n    List.repeat 0 list\n    --> []\n\n    List.partition fn []\n    --> ( [], [] )\n\n    List.partition (always True) list\n    --> ( list, [] )\n\n\n### Set\n\n    Set.map fn Set.empty -- same for Set.filter, Set.remove...\n    --> Set.empty\n\n    Set.map identity list\n    --> list\n\n    Set.map identity\n    --> identity\n\n    Set.isEmpty Set.empty\n    --> True\n\n    Set.member x Set.empty\n    --> False\n\n    Set.fromList []\n    --> Set.empty\n\n    Set.toList Set.empty\n    --> []\n\n    Set.length Set.empty\n    --> 0\n\n    Set.intersect Set.empty set\n    --> Set.empty\n\n    Set.diff Set.empty set\n    --> Set.empty\n\n    Set.diff set Set.empty\n    --> set\n\n    Set.union set Set.empty\n    --> set\n\n    Set.insert x Set.empty\n    --> Set.singleton x\n\n    Set.partition fn Set.empty\n    --> ( Set.empty, Set.empty )\n\n    Set.partition (always True) set\n    --> ( list, Set.empty )\n\n\n### Dict\n\n    Dict.isEmpty Dict.empty\n    --> True\n\n    Dict.fromList []\n    --> Dict.empty\n\n    Dict.toList Dict.empty\n    --> []\n\n    Dict.size Dict.empty\n    --> 0\n\n\n### Cmd / Sub\n\nAll of these also apply for `Sub`.\n\n    Cmd.batch []\n    --> Cmd.none\n\n    Cmd.batch [ a ]\n    --> a\n\n    Cmd.batch [ a, Cmd.none, b ]\n    --> Cmd.batch [ a, b ]\n\n    Cmd.map identity cmd\n    --> cmd\n\n    Cmd.map fn Cmd.none\n    --> Cmd.none\n\n","type":"Review.Rule.Rule"}],"binops":[]}]